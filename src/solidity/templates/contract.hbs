{{#*inline "transitionExpr"~}}
  {{#join matchIntervals " || "~}}
  c >= {{0}} && c <= {{1}}
  {{~/join}}
{{~/inline}}
pragma solidity ^0.4.11;

contract {{name}} {
  struct State {
    bool accepts;
    function (byte) constant internal returns (State memory) func;
  }

{{#if regex}}
  string public constant regex = "{{{regex}}}";

{{/if}}
  function s0(byte c) constant internal returns (State memory) {
    c = c;
    return State(false, s0);
  }

{{#states}}
  function s{{id}}(byte c) constant internal returns (State memory) {
{{#outputs}}
    if ({{> transitionExpr }}) {
      return State({{../accepts}}, s{{to}});
    }
{{/outputs}}
{{^outputs}}
    // silence unused var warning
    c = c;
{{/outputs}}

    return State(false, s0);
  }

{{/states}}
  function matches(string input) constant returns (bool) {
    var cur = State(false, s1);

    for (uint i = 0; i < bytes(input).length; i++) {
      var c = bytes(input)[i];

      cur = cur.func(c);
      if (cur.func == s0) {
        return false;
      }
    }

    return cur.accepts;
  }
}
